<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Particle Heart Animation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        /* Ẩn SVG gốc, chúng ta chỉ cần dữ liệu từ nó */
        svg { display: none; }
    </style>
</head>
<body>

<svg viewBox="0 0 600 552" xmlns="http://www.w3.org/2000/svg">
  <path d="M300,552 C530.2,418.6 600,218.6 600,137.4 C600,58.2 537.4,0 458.2,0 C406.6,0 354.8,30.4 300,72.8 C245.2,30.4 193.4,0 141.8,0 C62.6,0 0,58.2 0,137.4 C0,218.6 69.8,418.6 300,552 Z"/>
</svg>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

<script>
console.clear();
/* SETUP */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    // SỬA LỖI: Xóa các dòng chữ không hợp lệ
    5000
);
camera.position.z = 500;
const renderer = new THREE.WebGLRenderer();
renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* CONTROLS */
// Khi tải từ CDN, OrbitControls nằm trong namespace THREE
const controlsWebGL = new THREE.OrbitControls(camera, renderer.domElement);

/* PARTICLES */
// Create a global gsap timeline that contains all tweens
const tl = gsap.timeline({
    repeat: -1,
    yoyo: true
});

const path = document.querySelector("path");

// Khai báo biến geometry và vertices ở phạm vi rộng hơn
let geometry;
const vertices = [];

// Thêm kiểm tra để đảm bảo path tồn tại
if (!path) {
    console.error("Lỗi: Không tìm thấy phần tử SVG <path>.");
} else {
    const length = path.getTotalLength();

    // Tăng bước nhảy từ 0.1 lên 0.5 để giảm số lượng hạt, cải thiện hiệu suất
    for (let i = 0; i < length; i += 0.5) {
        const point = path.getPointAtLength(i);
        // Chuyển đổi tọa độ SVG sang THREE.js (Trục Y bị ngược)
        const vector = new THREE.Vector3(point.x, -point.y, 0);
        
        // Thêm ngẫu nhiên (fuzziness)
        vector.x += (Math.random() - 0.5) * 30;
        vector.y += (Math.random() - 0.5) * 30;
        vector.z += (Math.random() - 0.5) * 70;
        vertices.push(vector);

        // Create a tween for that vector
        tl.from(vector, {
            x: 600 / 2, // Center X of the heart
            y: -552 / 2, // Center Y of the heart
            z: 0, // Center of the scene
            ease: "power2.inOut",
            duration: "random(2, 5)" // Random duration
        },
        i * 0.002 // Delay calculated from the distance along the path
        );
    }

    geometry = new THREE.BufferGeometry().setFromPoints(vertices);
    // Thêm transparent: true để hiệu ứng blending hoạt động tốt hơn
    const material = new THREE.PointsMaterial( { color: 0xee5282, blending: THREE.AdditiveBlending, size: 3, transparent: true } );
    const particles = new THREE.Points(geometry, material);

    // Offset the particles in the scene based on the viewbox values để căn giữa
    particles.position.x -= 600 / 2;
    particles.position.y += 552 / 2;
    scene.add(particles);

    // Hiệu ứng xoay nhẹ cho toàn cảnh
    gsap.fromTo(scene.rotation, {
        y: -0.2
    }, {
        y: 0.2,
        repeat: -1,
        yoyo: true,
        ease: 'power2.inOut',
        duration: 3
    });
}


/* RENDERING */
function render() {
    requestAnimationFrame(render);
    // Update the geometry from the animated vertices (GSAP đang thay đổi mảng vertices)
    if (geometry) {
        geometry.setFromPoints(vertices);
    }
    renderer.render(scene, camera);
}

/* EVENTS */
// SỬA LỖI: Hoàn thiện hàm onWindowResize
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    // Sửa lỗi tên hàm: updateProj thành updateProjectionMatrix()
    camera.updateProjectionMatrix();
    // Cập nhật kích thước renderer
    renderer.setSize(window.innerWidth, window.innerHeight);
} // <-- Thêm dấu đóng hàm

// SỬA LỖI: Gắn sự kiện resize
window.addEventListener('resize', onWindowResize, false);

// SỬA LỖI: Gọi hàm render để bắt đầu animation
render();

</script>
</body>
</html>
